{"version":3,"sources":["edamame/impl/parser.cljc"],"mappings":"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","names":["edamame.impl.parser/parse-comment","reader","cljs.tools.reader.reader-types/read-line","var_args","G__64318","edamame.impl.parser/throw-reader","js/Error","msg","edamame.impl.parser.throw_reader","data","loc","c","cljs.tools.reader.reader-types/get-column-number","l","cljs.tools.reader.reader-types/get-line-number","cljs.core.ex_info","cljs.core.merge","G__64334","edamame.impl.parser/parse-to-delimiter","ctx","delimiter","edamame.impl.parser.parse_to_delimiter","into","row","col","opened","cljs.core.assoc","vals","cljs.core/transient","next-val","edamame.impl.parser/parse-next","cljs.core/keyword-identical?","cljs.core/persistent!","cljs.core.conj_BANG_","edamame.impl.parser/parse-list","cljs.core.apply","cljs.core/list","edamame.impl.parser/read-regex-pattern","_ctx","sb","js/goog.string.StringBuffer","ch","edamame.impl.parser/handle-dispatch","sharp?","f","regex?","and__4210__auto__","edamame.impl.parser/delimiter?","G__64363","edamame.impl.parser/location","edamame.impl.parser/duplicate-keys-error","coll","seq","iter__4611__auto__","s__64401","cljs.core/LazySeq","temp__5753__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4609__auto__","size__4610__auto__","cljs.core/count","b__64403","cljs.core/chunk-buffer","i__64402","vec__64412","cljs.core/-nth","cljs.core.nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__64400","cljs.core/chunk-rest","vec__64421","cljs.core/first","cljs.core/cons","cljs.core/rest","id","freq","cljs.core/frequencies","dups","duplicates","cljs.core/str","cljs.core.interpose","edamame.impl.parser/throw-dup-keys","kind","ks","clojure.string/capitalize","cljs.core/name","edamame.impl.parser/parse-set","start-loc","the-set","cljs.core/set","cljs.core._EQ_","edamame.impl.parser/parse-sharp","temp__5751__auto__","cljs.core.get_in","G__64455","cljs.tools.reader.edn.read","edamame.impl.parser/throw-odd-map","elements","cljs.tools.reader.impl.inspect.inspect","edamame.impl.parser/parse-map","cljs.core/odd?","cljs.core.take_nth","cljs.core/distinct?","cljs.core/hash-map","edamame.impl.parser/parse-unquote-splice","p__64474","map__64477","cljs.core/--destructure-map","dispatch","cljs.core.get","edamame.impl.parser/dispatch","path","vec__64478","or__4212__auto__","v","cljs.core/last","cljs.core.conj","cljs.core/pop","cljs.core/map?","G__64486","expected","cljs.core.not_EQ_","map__64496","char","map__64506","map__64521","edamame.impl.parser/whitespace?","edamame.impl.parser/parse-whitespace","cljs.tools.reader.reader-types/peek-char","obj","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","cljs.core/IWithMeta","cljs.core.vary_meta","cljs.core/merge","edamame.impl.parser/string-reader","s","cljs.tools.reader.reader_types.indexing_push_back_reader","cljs.tools.reader.reader_types.string_push_back_reader","edamame.impl.parser/parse-string","opts","r","edamame.impl.parser/parse-string-all","ret","cljs.core/chunk-first"],"sourcesContent":["(ns edamame.impl.parser\n  \"This code is largely inspired by rewrite-clj(sc), so thanks to all\n  who contribured to those projects.\"\n  {:no-doc true}\n  (:require\n   #?(:clj  [clojure.tools.reader.edn :as edn]\n      :cljs [cljs.tools.reader.edn :as edn])\n   #?(:clj  [clojure.tools.reader.reader-types :as r]\n      :cljs [cljs.tools.reader.reader-types :as r])\n   #?(:clj  [clojure.tools.reader.impl.inspect :as i]\n      :cljs [cljs.tools.reader.impl.inspect :as i])\n   [clojure.string :as s])\n  #?(:clj (:import [java.io Closeable]))\n  #?(:cljs (:import [goog.string StringBuffer])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(declare parse-next)\n\n(defn parse-comment\n  [#?(:cljs ^not-native reader :default reader)]\n  (r/read-line reader)\n  reader)\n\n(defn throw-reader\n  \"Throw reader exception, including line line/column. line/column is\n  read from the reader but it can be overriden by passing loc\n  optional parameter.\"\n  ([#?(:cljs ^:not-native reader :default reader) msg]\n   (throw-reader reader msg nil))\n  ([#?(:cljs ^:not-native reader :default reader) msg data]\n   (throw-reader reader msg data nil))\n  ([#?(:cljs ^:not-native reader :default reader) msg data loc]\n   (let [c (:col loc (r/get-column-number reader))\n         l (:row loc (r/get-line-number reader))]\n     (throw\n      (ex-info\n       (str msg\n            \" [at line \" l \", column \" c \"]\")\n       (merge {:row l, :col c} data))))))\n\n(defn parse-to-delimiter\n  ([ctx #?(:cljs ^not-native reader :default reader) delimiter]\n   (parse-to-delimiter ctx reader delimiter []))\n  ([ctx #?(:cljs ^not-native reader :default reader) delimiter into]\n   (let [row (r/get-line-number reader)\n         col (r/get-column-number reader)\n         opened (r/read-char reader)]\n     (let [ctx (assoc ctx\n                      ::expected-delimiter delimiter\n                      ::opened-delimiter {:char opened :row row :col col})]\n       (loop [vals (transient into)]\n         (let [;; if next-val is uneval, we get back the expected delimiter...\n               next-val (parse-next ctx reader)]\n           (cond\n             (#?(:clj identical? :cljs keyword-identical?) ::eof next-val)\n             (throw-reader\n              reader\n              (str \"EOF while reading, expected \" delimiter \" to match \" opened \" at [\" row \",\" col \"]\"))\n             (#?(:clj identical? :cljs keyword-identical?) ::expected-delimiter next-val)\n             (persistent! vals)\n             :else\n             (recur (conj! vals next-val)))))))))\n\n(defn parse-list [ctx #?(:cljs ^not-native reader :default reader)]\n  (apply list (parse-to-delimiter ctx reader \\))))\n\n(defn read-regex-pattern\n  \"Modeled after tools.reader/read-regex.\"\n  [_ctx #?(:cljs ^not-native reader :default reader)]\n  (r/read-char reader) ;; ignore leading double-quote\n  (let [sb #?(:clj (StringBuilder.)\n              :cljs (goog.string.StringBuffer.))]\n    (loop [ch (r/read-char reader)]\n      (if (identical? \\\" ch)\n        #?(:clj (str sb)\n           :cljs (str sb))\n        (if (nil? ch)\n          (throw-reader reader \"Error while parsing regex\")\n          (do\n            (.append sb ch )\n            (when (identical? \\\\ ch)\n              (let [ch (r/read-char reader)]\n                (when (nil? ch)\n                  (throw-reader reader \"Error while parsing regex\"))\n                (.append sb ch)))\n            (recur (r/read-char reader))))))))\n\n(defn handle-dispatch\n  [ctx #?(:cljs ^not-native reader :default reader) c sharp? f]\n  (let [regex? (and sharp? (identical? \\\" c))\n        next-val (if regex?\n                   (read-regex-pattern ctx reader)\n                   (parse-next ctx reader))]\n    (f next-val)))\n\n(defn delimiter? [c]\n  (case c\n    (\\{ \\( \\[ \\\") true\n    false))\n\n(defn location [#?(:cljs ^not-native reader :default reader)]\n  {:row (r/get-line-number reader)\n   :col (r/get-column-number reader)})\n\n(defn- duplicate-keys-error [msg coll]\n  ;; https://github.com/clojure/tools.reader/blob/97d5dac9f5e7c04d8fe6c4a52cd77d6ced560d76/src/main/cljs/cljs/tools/reader/impl/errors.cljs#L233\n  (letfn [(duplicates [seq]\n            (for [[id freq] (frequencies seq)\n                  :when (> freq 1)]\n              id))]\n    (let [dups (duplicates coll)]\n      (apply str msg\n             (when (> (count dups) 1) \"s\")\n             \": \" (interpose \", \" dups)))))\n\n(defn throw-dup-keys\n  [#?(:cljs ^not-native reader :default reader) loc kind ks]\n  (throw-reader\n   reader\n   (duplicate-keys-error\n    (str (s/capitalize (name kind)) \" literal contains duplicate key\")\n    ks)\n   nil\n   loc))\n\n(defn parse-set\n  [ctx #?(:cljs ^not-native reader :default reader)]\n  (let [start-loc (location reader)\n        coll (parse-to-delimiter ctx reader \\})\n        the-set (set coll)]\n    (when-not (= (count coll) (count the-set))\n      (throw-dup-keys reader start-loc :set coll))\n    the-set))\n\n(defn parse-sharp\n  [ctx #?(:cljs ^not-native reader :default reader)]\n  (r/read-char reader) ;; ignore sharp\n  (let [c (r/peek-char reader)]\n    (if-let [f (or (get-in ctx [:dispatch \\# c]))]\n      (do\n        (when-not (delimiter? c)\n          (r/read-char reader))\n        (handle-dispatch ctx reader c true f))\n      (case c\n        nil (throw-reader reader (str \"Unexpected EOF.\"))\n        \\{ (parse-set ctx reader)\n        \\( (parse-list ctx reader)\n        \\_ (do\n             (r/read-char reader) ;; read _\n             (edn/read ctx reader) ;; ignore next form\n             (parse-next ctx reader))\n        (do\n          (r/unread reader \\#)\n          (edn/read ctx reader))))))\n\n(defn throw-odd-map\n  [#?(:cljs ^not-native reader :default reader) loc elements]\n  (throw-reader\n   reader\n   (str\n    \"The map literal starting with \"\n    (i/inspect (first elements))\n    \" contains \"\n    (count elements)\n    \" form(s). Map literals must contain an even number of forms.\")\n   nil\n   loc))\n\n(defn parse-map\n  [ctx #?(:cljs ^not-native reader :default reader)]\n  (let [start-loc (location reader)\n        elements (parse-to-delimiter ctx reader \\})\n        c (count elements)]\n    (when (pos? c)\n      (when (odd? c)\n        (throw-odd-map reader start-loc elements))\n      (let [ks (take-nth 2 elements)]\n        (when-not (apply distinct? ks)\n          (throw-dup-keys reader start-loc :map ks))))\n    (apply hash-map elements)))\n\n(defn parse-unquote-splice [])\n\n(defn dispatch\n  [{:keys [:dispatch] :as ctx} #?(:cljs ^not-native reader :default reader) path]\n  (let [sharp? (= [\\#] path)]\n    (if sharp? (parse-sharp ctx reader)\n        (if-let [[c f]\n                 (or (when-let [v (get-in dispatch path)]\n                       [(last path) v])\n                     (when-let [v (get-in dispatch (conj (pop path) :default))]\n                       [nil v]))]\n          (cond\n            (map? f) (do (r/read-char reader)\n                         (recur ctx reader\n                                (conj path (r/peek-char reader))))\n            :else\n            (do\n              (when c\n                (r/read-char reader))\n              (handle-dispatch ctx reader c false f)))\n          (let [c (last path)]\n            (case c\n              nil ::eof\n              \\( (parse-list ctx reader)\n              \\[ (parse-to-delimiter ctx reader \\])\n              \\{ (parse-map ctx reader)\n              (\\} \\] \\)) (let [expected (::expected-delimiter ctx)]\n                           (if (not= expected c)\n                             (throw-reader reader\n                                           (str \"Unmatched delimiter: \" c\n                                                (when expected\n                                                  (str \", expected: \" expected\n                                                       (when-let [{:keys [:row :col :char]} (::opened-delimiter ctx)]\n                                                         (str \" to match \" char \" at \" [row col])))))\n                                           ctx)\n                             (do\n                               (r/read-char reader) ;; read delimiter\n                               ::expected-delimiter)))\n              \\; (parse-comment reader)\n              (edn/read ctx reader)))))))\n\n(defn whitespace?\n  [#?(:clj ^java.lang.Character c :default c)]\n  #?(:clj (and c (or (= c \\,) (Character/isWhitespace c)))\n     :cljs (and c (< -1 (.indexOf #js [\\return \\newline \\tab \\space \",\"] c)))))\n\n(defn parse-whitespace\n  [_ctx #?(:cljs ^not-native reader :default reader)]\n  (loop []\n    (let [c (r/read-char reader)]\n      (if (whitespace? c)\n        (recur)\n        (do (r/unread reader c)\n            reader)))))\n\n(defn parse-next [ctx reader]\n  (parse-whitespace ctx reader) ;; skip leading whitespace\n  (if-let [c (r/peek-char reader)]\n    (let [loc (location reader)\n          obj (dispatch ctx reader [c])]\n      (if (identical? reader obj)\n        (parse-next ctx reader)\n        (if #?(:clj\n               (instance? clojure.lang.IObj obj)\n               :cljs (satisfies? IWithMeta obj))\n          (vary-meta obj merge loc)\n          obj)))\n    ::eof))\n\n(defn string-reader\n  \"Create reader for strings.\"\n  [s]\n  (r/indexing-push-back-reader\n   (r/string-push-back-reader s)))\n\n(defn parse-string [s opts]\n  (let [^Closeable r (string-reader s)\n        ctx (assoc opts ::expected-delimiter nil)\n        v (parse-next ctx r)]\n    (if (identical? ::eof v) nil v)))\n\n(defn parse-string-all [s opts]\n  (let [^Closeable r (string-reader s)\n        ctx (assoc opts ::expected-delimiter nil)]\n    (loop [ret (transient [])]\n      (let [next-val (parse-next ctx r)]\n        (if (#?(:clj identical? :cljs keyword-identical?) ::eof next-val)\n          (persistent! ret)\n          (recur (conj! ret next-val)))))))\n\n;;;; Scratch\n\n(comment\n  )\n"]}